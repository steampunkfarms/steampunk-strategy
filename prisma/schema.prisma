generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
}

// =============================================================================
// TRANSACTIONS — The core financial ledger
// =============================================================================

model Transaction {
  id              String    @id @default(uuid())
  date            DateTime
  amount          Decimal   @db.Decimal(10, 2)
  type            String    // "expense" | "income" | "transfer" | "refund"
  description     String
  reference       String?   // Check #, invoice #, confirmation code
  paymentMethod   String?   @map("payment_method") // "check" | "card" | "ach" | "cash" | "paypal" | "donor_paid"

  // Categorization
  categoryId      String?   @map("category_id")
  category        ExpenseCategory? @relation(fields: [categoryId], references: [id])
  subcategory     String?   // Freeform or AI-suggested

  // Vendor link
  vendorId        String?   @map("vendor_id")
  vendor          Vendor?   @relation(fields: [vendorId], references: [id])

  // Source tracking
  source          String    @default("manual") // "manual" | "bank_import" | "gmail_scan" | "stripe_sync" | "receipt_scan"
  sourceId        String?   @map("source_id")  // External ID from source system
  bankRecordId    String?   @map("bank_record_id")
  bankRecord      BankRecord? @relation(fields: [bankRecordId], references: [id])

  // Tax/compliance
  taxDeductible   Boolean   @default(false) @map("tax_deductible")
  taxCategory     String?   @map("tax_category")  // IRS 990 line item
  fiscalYear      Int       @map("fiscal_year")

  // Status
  status          String    @default("pending") // "pending" | "verified" | "reconciled" | "flagged"
  flagReason      String?   @map("flag_reason")

  // Donor-paid vendor bills (e.g., donor calls Elston's to pay hay bill)
  donorPaidBill   DonorPaidBill?

  // Relations
  documents       TransactionDocument[]
  journalNotes    JournalNote[]
  transparencyItems TransparencyItem[]

  // Meta
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  createdBy       String?   @map("created_by")

  @@map("transactions")
  @@index([date])
  @@index([vendorId])
  @@index([categoryId])
  @@index([fiscalYear])
  @@index([status])
  @@index([source])
}

// =============================================================================
// DOCUMENTS — Scanned receipts, invoices, manifests, bank statements
// =============================================================================

model Document {
  id              String    @id @default(uuid())
  filename        String
  originalName    String    @map("original_name")
  mimeType        String    @map("mime_type")    // "application/pdf" | "image/jpeg" | etc.
  fileSize        Int       @map("file_size")     // bytes
  blobUrl         String    @map("blob_url")      // Vercel Blob URL

  // AI extraction
  extractedText   String?   @map("extracted_text") // Raw OCR/parsed text
  extractedData   String?   @map("extracted_data") // JSON: structured fields (date, vendor, amount, line items)
  parseStatus     String    @default("pending") @map("parse_status") // "pending" | "processing" | "complete" | "failed"
  parseModel      String?   @map("parse_model")   // Claude model used
  confidence      Decimal?  @db.Decimal(3, 2)      // AI confidence score 0.00-1.00

  // Classification
  docType         String    @map("doc_type") // "invoice" | "receipt" | "bank_statement" | "shipping_manifest" | "tax_form" | "filing" | "other"
  vendorId        String?   @map("vendor_id")
  vendor          Vendor?   @relation(fields: [vendorId], references: [id])

  // Relations
  transactions    TransactionDocument[]

  // Meta
  uploadedAt      DateTime  @default(now()) @map("uploaded_at")
  uploadedBy      String?   @map("uploaded_by")

  @@map("documents")
  @@index([docType])
  @@index([parseStatus])
  @@index([vendorId])
}

// Join table: transactions <-> documents (many-to-many)
model TransactionDocument {
  transactionId   String    @map("transaction_id")
  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  documentId      String    @map("document_id")
  document        Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@id([transactionId, documentId])
  @@map("transaction_documents")
}

// =============================================================================
// VENDORS — Recurring suppliers and service providers
// =============================================================================

model Vendor {
  id              String    @id @default(uuid())
  name            String
  slug            String    @unique
  type            String    // "feed_supplier" | "supplies" | "veterinary" | "utilities" | "soap_materials" | "shipping" | "services" | "other"

  // Contact
  phone           String?
  email           String?
  website         String?
  address         String?
  accountNumber   String?   @map("account_number")

  // Payment details
  paymentTerms    String?   @map("payment_terms")  // "net_30" | "on_delivery" | "prepaid"
  typicalAmount   Decimal?  @map("typical_amount") @db.Decimal(10, 2) // Average invoice for anomaly detection
  acceptsDonorPayment Boolean @default(false) @map("accepts_donor_payment") // Can donors call to pay?

  // Notes
  notes           String?
  tags            String?   // JSON array of tags

  // Relations
  transactions    Transaction[]
  documents       Document[]
  donorPaidBills  DonorPaidBill[]
  costTrackers    CostTracker[]
  seasonalBaselines SeasonalBaseline[]
  donorArrangements VendorDonorArrangement[]

  // Meta
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("vendors")
}

// =============================================================================
// VENDOR DONOR ARRANGEMENTS — Standing donor pre-payment agreements
// e.g., Ironwood Pig Sanctuary has a card on file at Star Milling,
// Star charges Ironwood $1,200/month before running the farm's card
// =============================================================================

model VendorDonorArrangement {
  id              String    @id @default(uuid())
  vendorId        String    @map("vendor_id")
  vendor          Vendor    @relation(fields: [vendorId], references: [id])

  // Donor info
  donorName       String    @map("donor_name")       // "Ironwood Pig Sanctuary"
  donorEmail      String?   @map("donor_email")      // "office@ironwoodpigs.org"
  donorPhone      String?   @map("donor_phone")      // "(520) 579-8847"
  donorAddress    String?   @map("donor_address")     // Mailing address for thank-yous
  donorId         String?   @map("donor_id")          // Studiolo donor ID if linked

  // Arrangement terms
  amount          Decimal   @db.Decimal(10, 2)        // $1,200.00
  frequency       String    // "monthly" | "quarterly" | "per_invoice" | "annual"
  method          String    // "pre_charge" (card on file) | "direct_payment" (donor calls) | "standing_order"
  description     String?   // Human-readable explanation of how it works

  // Once-per-period logic: only apply once per calendar period
  // When frequency="monthly", only the first invoice in a calendar month gets the credit
  oncePerPeriod   Boolean   @default(true) @map("once_per_period")

  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("vendor_donor_arrangements")
  @@index([vendorId])
  @@index([isActive])
}

// =============================================================================
// EXPENSE CATEGORIES — Hierarchical budget categories
// =============================================================================

model ExpenseCategory {
  id              String    @id @default(uuid())
  name            String
  slug            String    @unique
  parentId        String?   @map("parent_id")
  parent          ExpenseCategory? @relation("CategoryTree", fields: [parentId], references: [id])
  children        ExpenseCategory[] @relation("CategoryTree")

  // Budget
  annualBudget    Decimal?  @map("annual_budget") @db.Decimal(10, 2)
  irs990Line      String?   @map("irs_990_line") // Maps to IRS 990 form line

  // Display
  icon            String?   // Lucide icon name
  color           String?   // Tailwind color class
  sortOrder       Int       @default(0) @map("sort_order")

  // Relations
  transactions    Transaction[]

  @@map("expense_categories")
}

// =============================================================================
// DONOR-PAID VENDOR BILLS
// Special case: donors calling vendors directly to pay the farm's bill
// =============================================================================

model DonorPaidBill {
  id              String    @id @default(uuid())
  transactionId   String    @unique @map("transaction_id")
  transaction     Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  vendorId        String    @map("vendor_id")
  vendor          Vendor    @relation(fields: [vendorId], references: [id])

  donorName       String    @map("donor_name")
  donorEmail      String?   @map("donor_email")
  donorId         String?   @map("donor_id") // Studiolo donor ID if linked

  amount          Decimal   @db.Decimal(10, 2)
  paidDate        DateTime  @map("paid_date")
  coverageType    String    @map("coverage_type") // "full" | "partial"
  invoiceRef      String?   @map("invoice_ref")   // Which invoice this covers

  // Acknowledgment
  thanked         Boolean   @default(false)
  thankedDate     DateTime? @map("thanked_date")
  receiptSent     Boolean   @default(false) @map("receipt_sent")

  notes           String?

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("donor_paid_bills")
  @@index([vendorId])
  @@index([donorId])
}

// =============================================================================
// BANK IMPORTS — Imported bank statement batches and individual records
// =============================================================================

model BankImport {
  id              String    @id @default(uuid())
  filename        String
  bankName        String    @map("bank_name")
  accountLast4    String?   @map("account_last4")
  periodStart     DateTime  @map("period_start")
  periodEnd       DateTime  @map("period_end")
  recordCount     Int       @map("record_count")
  totalDebits     Decimal   @map("total_debits") @db.Decimal(10, 2)
  totalCredits    Decimal   @map("total_credits") @db.Decimal(10, 2)
  status          String    @default("imported") // "imported" | "reviewing" | "reconciled"

  records         BankRecord[]

  importedAt      DateTime  @default(now()) @map("imported_at")
  importedBy      String?   @map("imported_by")

  @@map("bank_imports")
}

model BankRecord {
  id              String    @id @default(uuid())
  importId        String    @map("import_id")
  import          BankImport @relation(fields: [importId], references: [id], onDelete: Cascade)

  date            DateTime
  description     String    // Raw bank description
  amount          Decimal   @db.Decimal(10, 2)
  type            String    // "debit" | "credit"
  balance         Decimal?  @db.Decimal(10, 2)
  checkNumber     String?   @map("check_number")

  // AI matching
  matchedVendor   String?   @map("matched_vendor")  // AI-suggested vendor name
  matchedCategory String?   @map("matched_category") // AI-suggested category
  matchConfidence Decimal?  @map("match_confidence") @db.Decimal(3, 2)

  // Link to transaction (once reconciled)
  transactions    Transaction[]
  status          String    @default("unmatched") // "unmatched" | "matched" | "reconciled" | "skipped"

  @@map("bank_records")
  @@index([importId])
  @@index([date])
  @@index([status])
}

// =============================================================================
// COMPLIANCE — Recurring filings, deadlines, regulatory tasks
// =============================================================================

model ComplianceTask {
  id              String    @id @default(uuid())
  name            String    // "CA Secretary of State Statement of Information"
  slug            String    @unique
  description     String?
  authority       String    // "IRS" | "CA_SOS" | "CA_AG" | "CA_FTB" | "GuideStar" | "Candid" | "County" | "Internal"
  category        String    // "tax_filing" | "state_filing" | "charity_registration" | "reporting" | "renewal" | "sales_tax"

  // Schedule
  frequency       String    // "annual" | "quarterly" | "monthly" | "biennial" | "one_time"
  dueMonth        Int?      @map("due_month")   // 1-12
  dueDay          Int?      @map("due_day")      // 1-31
  dueDayOfQuarter Int?      @map("due_day_of_quarter") // For quarterly tasks
  reminderDays    Int       @default(30) @map("reminder_days") // Days before due to start reminding

  // Filing details
  filingUrl       String?   @map("filing_url")   // Direct link to filing portal
  requiresPayment Boolean   @default(false) @map("requires_payment")
  estimatedCost   Decimal?  @map("estimated_cost") @db.Decimal(10, 2)
  penalty         String?   // Description of late penalties

  // Data dependencies
  dependsOn       String?   @map("depends_on") // JSON: what data needs to be ready (e.g., "expenses_reconciled", "990_prepared")

  // Relations
  completions     ComplianceCompletion[]

  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("compliance_tasks")
}

model ComplianceCompletion {
  id              String    @id @default(uuid())
  taskId          String    @map("task_id")
  task            ComplianceTask @relation(fields: [taskId], references: [id])

  fiscalYear      Int       @map("fiscal_year")
  period          String?   // "Q1" | "Q2" | "2025" | "2025-01" depending on frequency
  dueDate         DateTime  @map("due_date")
  status          String    @default("upcoming") // "upcoming" | "in_progress" | "completed" | "overdue" | "extended"

  completedDate   DateTime? @map("completed_date")
  completedBy     String?   @map("completed_by")
  confirmationNum String?   @map("confirmation_num")
  amountPaid      Decimal?  @map("amount_paid") @db.Decimal(10, 2)
  notes           String?

  // Attached documents (filed forms, confirmations)
  documentIds     String?   @map("document_ids") // JSON array of Document IDs

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("compliance_completions")
  @@unique([taskId, fiscalYear, period])
  @@index([status])
  @@index([dueDate])
}

// =============================================================================
// JOURNAL NOTES — Per-transaction or general financial notes
// =============================================================================

model JournalNote {
  id              String    @id @default(uuid())
  content         String
  type            String    @default("note") // "note" | "review" | "question" | "flag" | "decision"

  // Optional links
  transactionId   String?   @map("transaction_id")
  transaction     Transaction? @relation(fields: [transactionId], references: [id])
  vendorSlug      String?   @map("vendor_slug")
  complianceSlug  String?   @map("compliance_slug")
  reviewPeriod    String?   @map("review_period") // "2025-Q1" | "2025-01" for periodic reviews

  createdAt       DateTime  @default(now()) @map("created_at")
  createdBy       String?   @map("created_by")

  @@map("journal_notes")
  @@index([transactionId])
  @@index([reviewPeriod])
}

// =============================================================================
// COST TRACKING — Unit price history for ANY tracked item
// Covers soap COGS, hay, grain, specialty feeds, supplements — anything
// where you want to detect price creep or negotiate better.
// =============================================================================

model CostTracker {
  id              String    @id @default(uuid())
  vendorId        String    @map("vendor_id")
  vendor          Vendor    @relation(fields: [vendorId], references: [id])

  item            String    // "bermuda_hay" | "three_way_hay" | "alfalfa" | "straw" | "lye" | "coconut_oil" | etc.
  itemGroup       String?   @map("item_group")  // "hay" | "grain" | "soap_materials" | "specialty_feed" — for grouping
  unit            String    // "bale" | "ton" | "lb" | "oz" | "each" | "bag" | "case"
  quantity        Decimal?  @db.Decimal(10, 2)   // Qty on this invoice (for weighted averages)
  unitCost        Decimal   @map("unit_cost") @db.Decimal(10, 4)

  // Change tracking (filled by scanner comparing to previous entry)
  previousCost    Decimal?  @map("previous_cost") @db.Decimal(10, 4)
  percentChange   Decimal?  @map("percent_change") @db.Decimal(5, 2)

  // Seasonal comparison (filled by scanner comparing to same month prior year)
  priorYearCost   Decimal?  @map("prior_year_cost") @db.Decimal(10, 4) // Same month, previous year
  yoyChange       Decimal?  @map("yoy_change") @db.Decimal(5, 2)       // Year-over-year % change
  seasonalFlag    String?   @map("seasonal_flag") // null | "expected" | "above_expected" | "below_expected" | "cost_creep"

  recordedDate    DateTime  @map("recorded_date")
  month           Int?      // 1-12, for easy seasonal queries
  fiscalYear      Int?      @map("fiscal_year")
  invoiceRef      String?   @map("invoice_ref")

  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("cost_trackers")
  @@index([vendorId])
  @@index([item])
  @@index([itemGroup])
  @@index([recordedDate])
  @@index([month, fiscalYear])
}

// =============================================================================
// SEASONAL BASELINES — Expected price ranges by month for seasonal items
// The cost-creep scanner checks against these instead of blindly comparing
// to last month. Hay climbs Feb→Sep every year — that's not a red flag.
// But Sep 2026 > Sep 2025 + 10% threshold? That's real cost creep.
// =============================================================================

model SeasonalBaseline {
  id              String    @id @default(uuid())
  vendorId        String?   @map("vendor_id")    // null = industry-wide baseline
  vendor          Vendor?   @relation(fields: [vendorId], references: [id])

  item            String    // "bermuda_hay" | "three_way_hay" | "alfalfa" | etc.
  itemGroup       String?   @map("item_group")   // "hay" | "grain"
  unit            String    // "bale"

  month           Int       // 1-12
  baselineYear    Int       @map("baseline_year") // Year this data was captured (2025)

  // Price expectations
  expectedLow     Decimal   @map("expected_low")  @db.Decimal(10, 4)
  expectedHigh    Decimal   @map("expected_high") @db.Decimal(10, 4)
  typicalPrice    Decimal   @map("typical_price") @db.Decimal(10, 4) // Midpoint or observed

  // Seasonal context
  seasonPhase     String?   @map("season_phase")  // "post_harvest" | "depletion" | "peak" | "new_harvest"
  notes           String?                          // "Warehouses flush, best prices" etc.

  // Alerting thresholds
  creepThreshold  Decimal   @default(0.10) @map("creep_threshold") @db.Decimal(5, 2) // 10% above expected_high = flag

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@unique([vendorId, item, month, baselineYear])
  @@map("seasonal_baselines")
  @@index([item, month])
  @@index([vendorId])
}

// =============================================================================
// TRANSPARENCY — Public-facing financial data for Rescue Barn
// =============================================================================

model TransparencyItem {
  id              String    @id @default(uuid())
  transactionId   String?   @map("transaction_id")
  transaction     Transaction? @relation(fields: [transactionId], references: [id])

  category        String    // "feed_grain" | "veterinary" | "shelter" | "general_operations"
  displayLabel    String    @map("display_label")   // "Feed & Grain — Hay" (public-facing)
  amount          Decimal   @db.Decimal(10, 2)
  period          String    // "2025-01" | "2025-Q1"
  donorCovered    Decimal   @default(0) @map("donor_covered") @db.Decimal(10, 2) // Portion paid by donor directly

  isPublished     Boolean   @default(false) @map("is_published")
  publishedAt     DateTime? @map("published_at")

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("transparency_items")
  @@index([category])
  @@index([period])
  @@index([isPublished])
}

// =============================================================================
// PERSONAL/FARM RECONCILIATION
// Annual review of commingled purchases. When farm and personal accounts
// overlap (Amazon, Chewy, TSC, etc.), purchases need to be sorted each
// January. The queue presents suspected items; Fred marks each as "farm"
// or "personal"; the system calculates the net and creates the settlement.
//
// Directions:
//   "personal_on_farm" — Personal item paid by farm account. Farm is owed.
//   "farm_on_personal" — Farm item paid by personal account. Founder is owed.
// =============================================================================

model ReconciliationSession {
  id              String    @id @default(uuid())
  fiscalYear      Int       @map("fiscal_year") @unique
  status          String    @default("pending") // "pending" | "open" | "in_review" | "settled"

  // Opened/closed
  openedAt        DateTime? @map("opened_at")
  openedBy        String?   @map("opened_by")
  settledAt       DateTime? @map("settled_at")
  settledBy       String?   @map("settled_by")

  // Tallies (computed when settled)
  personalOnFarmTotal  Decimal?  @map("personal_on_farm_total") @db.Decimal(10, 2) // Farm is owed this
  farmOnPersonalTotal  Decimal?  @map("farm_on_personal_total") @db.Decimal(10, 2) // Founder is owed this
  netBalance           Decimal?  @map("net_balance") @db.Decimal(10, 2)            // Positive = founder owes farm
  itemCount            Int?      @map("item_count")
  resolvedCount        Int?      @map("resolved_count")

  // Settlement
  resolution      String?   // "donation_to_farm" | "reimbursement_to_founder" | "donation_from_founder" | "zero_balance"
  settlementAmount Decimal? @map("settlement_amount") @db.Decimal(10, 2)
  settlementMethod String?  @map("settlement_method") // "zeffy" | "check" | "ach" | "card" | "internal"
  settlementRef   String?   @map("settlement_ref")    // Confirmation #, check #, Zeffy donation ID
  settlementNote  String?   @map("settlement_note")   // "Rounded up $23.17 → $25 as additional donation"
  padAmount       Decimal?  @map("pad_amount") @db.Decimal(10, 2) // Extra donated beyond net balance

  // Relations
  items           CommingledItem[]

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("reconciliation_sessions")
}

model CommingledItem {
  id              String    @id @default(uuid())
  sessionId       String    @map("session_id")
  session         ReconciliationSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  // The purchase
  date            DateTime
  amount          Decimal   @db.Decimal(10, 2)
  description     String
  vendor          String?   // "Amazon" | "Chewy" | "Tractor Supply" | freeform
  orderRef        String?   @map("order_ref") // Amazon order #, etc.

  // Which direction is the suspicion?
  direction       String    // "personal_on_farm" | "farm_on_personal"
  account         String?   // Which account was charged: "farm_amazon" | "personal_amazon" | "farm_card" | "personal_card"

  // How it got here
  source          String    @default("manual") // "manual" | "gmail_scan" | "bank_import" | "ai_flagged"
  transactionId   String?   @map("transaction_id") // Link to the Transaction record if one exists
  confidence      Decimal?  @db.Decimal(3, 2)       // AI confidence it's commingled (0.00-1.00)
  flagReason      String?   @map("flag_reason")     // "Item 'Kindle Paperwhite' on farm Amazon unlikely farm expense"

  // Resolution
  status          String    @default("pending") // "pending" | "farm" | "personal" | "split" | "skipped"
  resolvedAt      DateTime? @map("resolved_at")
  resolvedBy      String?   @map("resolved_by")
  resolvedNote    String?   @map("resolved_note") // "Actually farm — tablet for barn webcam display"

  // For split items (part farm, part personal on same order)
  farmPortion     Decimal?  @map("farm_portion") @db.Decimal(10, 2)
  personalPortion Decimal?  @map("personal_portion") @db.Decimal(10, 2)

  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@map("commingled_items")
  @@index([sessionId])
  @@index([status])
  @@index([direction])
  @@index([transactionId])
}

// =============================================================================
// ACCOUNT REGISTRY — Which purchasing accounts belong to farm vs. personal
// Used by the scanner to flag cross-account purchases automatically.
// =============================================================================

model PurchasingAccount {
  id              String    @id @default(uuid())
  name            String    // "Farm Amazon" | "Personal Amazon" | "RaiseRight Card"
  slug            String    @unique
  owner           String    // "farm" | "personal_fred" | "personal_krystal"
  platform        String    // "amazon" | "chewy" | "tractor_supply" | "card" | "other"
  email           String?   // Email associated with the account
  last4           String?   // Last 4 of card for matching bank records
  notes           String?

  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("purchasing_accounts")
}

// =============================================================================
// AUDIT LOG — Who did what when
// =============================================================================

model AuditLog {
  id              String    @id @default(uuid())
  action          String    // "create" | "update" | "delete" | "import" | "parse" | "publish" | "sync"
  entity          String    // "transaction" | "document" | "vendor" | "compliance" | etc.
  entityId        String?   @map("entity_id")
  details         String?   // JSON: what changed
  userId          String?   @map("user_id")
  userName        String?   @map("user_name")
  ipAddress       String?   @map("ip_address")

  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("audit_logs")
  @@index([entity, entityId])
  @@index([createdAt])
  @@index([userId])
}

// =============================================================================
// RAISERIGHT — Gift card fundraising earnings tracking
// Data sourced from manual CSV exports and Gmail notification scanning.
// No API available — RaiseRight does not offer one.
// =============================================================================

// Individual CSV upload batches
model RaiserightImport {
  id              String    @id @default(uuid())
  filename        String
  reportType      String    @map("report_type") // "earnings_summary" | "order_history" | "deposit_slip" | "participant_list"
  periodStart     DateTime? @map("period_start")
  periodEnd       DateTime? @map("period_end")
  recordCount     Int       @map("record_count")
  totalEarnings   Decimal?  @map("total_earnings") @db.Decimal(10, 2)
  status          String    @default("imported") // "imported" | "reviewed" | "archived"
  notes           String?

  // Relations
  earnings        RaiserightEarning[]
  orders          RaiserightOrder[]

  importedAt      DateTime  @default(now()) @map("imported_at")
  importedBy      String?   @map("imported_by")

  @@map("raiseright_imports")
  @@index([reportType])
  @@index([importedAt])
}

// Per-participant earnings (from "Earnings Summary by Participant" CSV)
model RaiserightEarning {
  id              String    @id @default(uuid())
  importId        String    @map("import_id")
  import          RaiserightImport @relation(fields: [importId], references: [id], onDelete: Cascade)

  participantName String    @map("participant_name")
  participantEmail String?  @map("participant_email")
  earnings        Decimal   @db.Decimal(10, 2)
  orderCount      Int?      @map("order_count")
  period          String    // "2026-02" or "2026-Q1" — normalized from CSV date range
  fiscalYear      Int       @map("fiscal_year")

  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("raiseright_earnings")
  @@index([period])
  @@index([fiscalYear])
  @@index([participantName])
}

// Individual orders (from "Order History by Participant" CSV)
model RaiserightOrder {
  id              String    @id @default(uuid())
  importId        String    @map("import_id")
  import          RaiserightImport @relation(fields: [importId], references: [id], onDelete: Cascade)

  orderDate       DateTime  @map("order_date")
  participantName String    @map("participant_name")
  brandName       String    @map("brand_name")
  denomination    Decimal   @db.Decimal(10, 2)     // Face value of the card
  earningRate     Decimal   @map("earning_rate") @db.Decimal(5, 4) // e.g., 0.0400 for 4%
  earnings        Decimal   @db.Decimal(10, 2)
  productType     String?   @map("product_type")   // "egift" | "physical" | "reload"
  poNumber        String?   @map("po_number")

  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("raiseright_orders")
  @@index([orderDate])
  @@index([brandName])
  @@index([participantName])
}

// Monthly deposit records (from "Monthly Deposit Slip" CSV or Gmail notifications)
model RaiserightDeposit {
  id              String    @id @default(uuid())
  depositDate     DateTime  @map("deposit_date")
  amount          Decimal   @db.Decimal(10, 2)
  period          String    // "2026-02"
  orderCount      Int?      @map("order_count")
  participantCount Int?     @map("participant_count")
  source          String    @default("csv") // "csv" | "gmail_scan" | "manual"
  sourceId        String?   @map("source_id") // Gmail message ID or import ID
  notes           String?

  // Link to the transaction record once reconciled
  transactionId   String?   @unique @map("transaction_id")

  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("raiseright_deposits")
  @@index([depositDate])
  @@index([period])
}

// Participant roster snapshot (from "Participant Summary" CSV)
model RaiserightParticipant {
  id              String    @id @default(uuid())
  name            String
  email           String?   @unique
  enrolledAt      DateTime? @map("enrolled_at")
  lastOrderDate   DateTime? @map("last_order_date")
  totalEarnings   Decimal   @default(0) @map("total_earnings") @db.Decimal(10, 2)
  totalOrders     Int       @default(0) @map("total_orders")
  status          String    @default("active") // "active" | "dormant" | "new"

  updatedAt       DateTime  @updatedAt @map("updated_at")
  createdAt       DateTime  @default(now()) @map("created_at")

  @@map("raiseright_participants")
  @@index([status])
  @@index([lastOrderDate])
}
